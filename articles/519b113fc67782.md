---
title: "AIエージェントとGitHub Issueで実現する新しい開発スタイル"
emoji: "🤖"
type: "tech"
topics: ["github", "ai", "development", "windsurf"]
published: false
---

# GitHub IssueをAIの"外部メモリ"にすると開発が劇的に楽になる話
AIエージェントが発達し、
Cursor, Cline, Windsurf, VSCode Copilotなど、様々なAIツールが登場し、開発の効率が格段に上がってきていますよね！

自分自身は、WindsurfやClineを活用し、直近ではAIエージェントを活用しながら開発を進めています。

でも、AIと一緒に開発を進めていると、こんな悩みを感じたことはありませんか?

- 一時会話が切れてしまうと、作業中のコンテキストが失われしまう 😫
- 試行錯誤しながら開発をを進めているうちに、やり取りが長くなり、思い通りに指示が通りにくくなる 😫
- AIの作業履歴が残らない 🤔

今回は、これらの課題をGitHub Issueを使って解決する方法をご紹介します。具体的には、AIエージェント にGitHub Issueを「外部メモリ」として使わせる手法です。

## なぜGitHub Issueなのか?
今回は、これらの課題を**GitHub Issue**を使って解決する方法をご紹介します。具体的には、AIエージェント（Cline, Cursor, Windsurf, VSCode Copilotなど）にGitHub Issueを「外部メモリ」として使わせる手法です。

## なぜGitHub Issueなのか？
実は、GitHub Issueには以下のような特徴があり、AIエージェントの「外部メモリ」として最適なんです：

- MCPサーバーを使って、AIエージェントが直接読み書きできる
- 人間もAIも使い慣れたツールである
- 作業の進捗や問題点を記録しやすい


## なぜGitHub Issueなのか？

「えっ、GitHub Issue？それって人間が使うものじゃないの？」と思われるかもしれません。

実は、GitHub Issueには以下のような特徴があり、AIの「外部メモリ」として最適なんです：

- **MCPサーバーを使って、AIエージェントが直接読み書きできる**
- **人間もAIも使い慣れたツールである**
- **作業の進捗や問題点を記録しやすい**

### MCPサーバーを使うと何が良いのか？

MCP（Model Context Protocol）サーバーを使うことで、AIエージェントはGitHub Issueを直接操作できます。
例えば、Issueの作成やコメントの追加、タグの変更などをAIが行うことで、AIのコンテキストをGitHub上に保持し、セッションが切れても継続的に作業を進めることができます。

<!-- ここにMCPサーバーの詳細についての説明を追加 -->

こうすることで、AIがIssueを管理しながら開発を進めることができ、履歴をGitHub上にしっかり残せます。

### 人間とAIの共通基盤としてのGitHub
GitHubは、エンジニアにとって馴染みのあるプラットフォームであり、IssueやPR、コミットを活用するのは日常的な作業です。

一方、AIもGitHubのデータを学習しており、その構造を理解しているため、Issueの管理や変更履歴の把握が得意です。つまり、人間とAIの間でスムーズなやり取りができるという点が大きなメリットになります。

例えば、AIがIssueに「どの変更をどのように行うべきか」を記録しておけば、人間の開発者が後からそのIssueを見て、状況をすぐに把握できます。

```markdown
# Implementation Update: Using StartLiveTail API

## Why this change?
- Native AWS streaming APIを使うことで、パフォーマンスが向上
- 既存のポーリング処理を廃止し、よりリアルタイムなログ取得が可能に
- リクエスト回数を減らし、コスト最適化も実現

## Next Steps
1. 新しいAPIのテスト実装
2. 既存コードとの統合
3. エラーハンドリングの見直し
```

こうした形で、AIがGitHub Issueを活用することで、開発の透明性を向上させ、非同期のコラボレーションがよりスムーズに行えます。


## 実際のAIとの開発風景を覗いてみよう

具体例として、私が開発しているECSのログをCLIで扱えるようにする[ecs-log-viewer](https://github.com/bonyuta0204/ecs-log-viewer)の開発時における、
活用例を見てみましょう。

このツールに「ログのライブストリーミング機能」を追加する際、AIエージェントにIssueを「外部メモリ」として活用させながら開発を進めました。
[Issue #10](https://github.com/bonyuta0204/ecs-log-viewer/issues/10)を見ると、AIが以下のような形で作業を記録しています。

1. 実装計画を立て、タスクを整理
2. 実装中に発生した課題を記録し、解決策を整理
3. 進捗を更新しながら、テストやリファクタリングを反映

実は、AIエージェントが「StartLiveTail API」を使う実装方針をIssueに記録したのは、私がIssueの内容を見て「ポーリングじゃなくてストリーミングAPIを使うほうがいいんじゃない？」とチャットで指示した結果でした。  
するとAIは、それを設計の見直しとして捉え、Issueの更新を行いました。

```markdown
# Implementation Update: Using StartLiveTail API

## Why this change?
1. **Native Streaming**: AWSのネイティブストリーミングを利用できる
2. **Better Performance**: 1秒ごとに最大500イベントの更新が可能
3. **Automatic Rate Limiting**: AWSがバッファリングとレート制御を管理
4. **Session Management**: 3時間ごとのタイムアウトを考慮
5. **Error Handling**: 明確なエラータイプごとに例外処理が可能

## Next Steps
- AWS SDKのバージョンをv1.30.0以降にアップデート
- `CloudWatchClient`を新APIに対応する形でリファクタリング
- エラーハンドリングの追加
- 既存のテストケースの見直しと新機能に合わせた追加
```

このように、**AIがIssueに記録することで、私がフィードバックを与え、それを反映する形でIssueがアップデートされる**という、  
「AIエージェントと人間が共同で作業を進める」フローが自然と生まれました。

## AIと人間の協力による開発の進め方

GitHub Issueを「外部メモリ」として使うことで、AIと人間が協力しながら開発を進めやすくなります。

- **作業の記録が残るため、中断後もすぐに再開できる**  
  → 例えば、AIが夜間にIssueを更新し、人間の開発者が翌日にレビューしてフィードバックを追加

- **AIが行った作業の履歴が分かりやすい**  
  → Issueに過去の決定や変更履歴が残るため、「なぜこの実装を選んだのか」が後からでも理解できる

- **人間がコメントを追加して、方向修正や補足ができる**  
  → 「エラーハンドリングを強化したほうがいい」「このAPIの仕様を再確認してほしい」などの指示をIssue上で共有

このように、AIと人間がIssue上でやり取りをしながら開発を進めることで、**よりスムーズな非同期コラボレーション**が実現できます。

## AIを活用した記録の自動化とレビューの組み合わせ

[PR #16](https://github.com/bonyuta0204/ecs-log-viewer/pull/16)では、Issueの履歴を元に実装の詳細な記録が残され、テスト計画や品質管理まで、すべてがトレース可能になっています。

AIの活用によってIssueの管理が徹底され、**作業の流れが整理されることで、開発チーム全体の生産性向上につながる**のがこのアプローチの大きなメリットです。


## セットアップ方法

では、実際にこの開発スタイルを試してみましょう。

### 1. Windsurfの設定

Windsurfでは、`.windsurfrules`ファイルにAIエージェントへの指示を記述します。以下は、GitHub Issueを効果的に活用するための設定例です：

```markdown
## Instructions

### 1. Issue Management
- 新しいタスクを開始する際はIssueを作成
- 同じIssueを継続して使用
- 進捗は既存のコメントを更新（簡潔に！）

### 2. Using Issues for Memory
- 過去のコメントを参照
- 重要な決定は必ず記録
...
```

また、GitHub連携のために、GitHub MCP serverを利用するよう設定します。

:::message
Cursor や Cline をお使いの方は、それぞれのツールの設定ファイルで同様の設定が可能です。詳細は各ツールのドキュメントをご確認ください。
:::

### 2. AIとの実際のやり取り：行き詰まり事例

AIとの開発で面白いのは、AIが自分で「ここは人間の助けが必要」と判断できる点です。

実際の例を見てみましょう。ecs-log-viewerでLiveStreamAPIの実装時、AIは以下のように行き詰まりを報告しました：

```markdown
# Progress Update: LiveStream API Implementation

## Current Blockers
- テストの失敗が続いています
- API呼び出しのタイミングに問題がある可能性
- エラーハンドリングの見直しが必要

## Next Steps
人間の開発者の方へ：
1. テストケースの見直しをお願いします
2. API呼び出しの順序について確認が必要です
3. エラー発生時の動作仕様の明確化をお願いします
```

このように、AIは：
1. 現在の状況を簡潔に説明
2. 具体的な問題点を列挙
3. 必要な対応を明確に提示

という形で、人間との協力を求めています。

### 3. 効果的なIssue管理のコツ

AIの記録は簡潔であることが重要です。長すぎる報告は読みづらく、後から参照する際も時間がかかります。

以下のような指示をプロンプトに含めることで、AIの報告を簡潔にできます：

```markdown
### Troubleshooting & Reporting
- 状況報告は簡潔に
- 重要な情報のみを含める
- 例：
  ✅ "APIアクセスエラーが発生。認証を確認中"
  ❌ "APIにアクセスしようとしたところエラーが発生し、認証方法を確認しています。様々な方法を試していますが..."
```

## AIとの実際のやり取りを見てみよう

私の開発プロジェクトから、実際のAIとのやり取りを紹介します。以下は、ecs-log-viewerでライブストリーミング機能を実装する際のものです。

### 1. AIが自主的に機能を設計

[Issue #10](https://github.com/bonyuta0204/ecs-log-viewer/issues/10)を見ると、AIが自分で：

```markdown
## Implementation Tasks
- Add tail flag to CLI options
- Add tail option to AppOption struct
- Implement TailLogs method in CloudWatchClient
- Create log writer interfaces for different output formats
...
```

というように、必要なタスクを細かく分解して整理しています。人間の指示を待つのではなく、自分で考えて計画を立てているんですね。

### 2. 問題解決の過程も記録

途中で実装方法を変更する必要が出てきた時も、AIは自分で判断し、その理由を記録しています：

```markdown
# Implementation Update: Using StartLiveTail API
Benefits:
- より効率的なログストリーミング
- AWSのベストプラクティスに準拠
- エラーハンドリングが改善
```

これは後から見返した時に、なぜその判断をしたのかが分かるので非常に便利です。

### 3. テストまでしっかりケア

[PR #16](https://github.com/bonyuta0204/ecs-log-viewer/pull/16)を見ると、AIが実装だけでなく、テストまでしっかり考えていることが分かります：

```markdown
### 4. Testing
- Unit tests for CloudWatch client
- Integration tests for CLI app
- Test cases for all output formats
- Error case coverage
```

人間のレビューアーが見ても分かりやすい、きちんとした品質管理ができているんです。

## この開発スタイルのメリット

このように GitHub Issue を AI の「外部メモリ」として使うことで、以下のようなメリットがあります：

### 1. 作業が途切れない 🔄
- AIのセッションが切れても、Issue を見れば続きから再開できる
- 人間が介入するタイミングを自由に選べる

### 2. チーム開発との相性が抜群 👥
- レビューがしやすい（普段使ってるGitHubの機能だから！）
- 他のメンバーも進捗が把握しやすい
- コードの変更履歴が自然に残る

### 3. AIの判断プロセスが見える 🤔
- なぜその実装方法を選んだのか
- どんな問題に直面したのか
- どうやって解決したのか

全てが Issue に記録として残るので、後から振り返ることができます。

## 注意点とTips 💡

とは言え、いくつか気をつけるポイントもあります：

### 1. AIへの適切な指示
- Issue の使い方についてしっかりとルールを設定
- 同じIssueを使い続けるよう指示
- 重要な判断は必ず記録するよう指示

### 2. Issue管理のコツ
- 1つの機能開発につき1つのIssue
- 進捗報告は既存のコメントを更新
- 人間からのフィードバックは明確に

### 3. レビューのポイント
- AIの判断が適切か
- 実装方針に問題はないか
- テスト計画は十分か

## さいごに

AIとの開発は、まだまだ発展途上です。でも、GitHub Issue という馴染みのあるツールを「AIの外部メモリ」として活用することで、より実用的な開発プロセスが実現できます。

皆さんも、ぜひ試してみてください！きっと、AIとの開発がもっと楽しくなるはずです。😊

## 参考リンク
- [ecs-log-viewer](https://github.com/bonyuta0204/ecs-log-viewer)
- [Issue #10: Add tail option for live log streaming](https://github.com/bonyuta0204/ecs-log-viewer/issues/10)
- [PR #16: Fix live log streaming and add test coverage](https://github.com/bonyuta0204/ecs-log-viewer/pull/16)
